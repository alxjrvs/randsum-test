"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var parse_arguments_1 = require("./parse-arguments");
describe('parseArguments', function () {
    describe('given a number string', function () {
        test('returns a RollParameter matching the notation', function () {
            expect((0, parse_arguments_1.parseArguments)('2')).toMatchObject({ quantity: 1, sides: 2 });
        });
        describe('and a complex RandsumOption', function () {
            test('returns a RollParameter matching the notation', function () {
                expect((0, parse_arguments_1.parseArguments)('2', { detailed: true })).toMatchObject({
                    quantity: 1,
                    sides: 2,
                    detailed: true,
                });
            });
        });
    });
    describe('given a number', function () {
        test('returns a RollParameter matching the notation', function () {
            expect((0, parse_arguments_1.parseArguments)(2)).toMatchObject({ quantity: 1, sides: 2 });
        });
    });
    describe('given Roll Options', function () {
        describe('simple', function () {
            test('returns a RollParameter matching the notation', function () {
                expect((0, parse_arguments_1.parseArguments)({
                    quantity: 4,
                    sides: '6',
                    modifiers: [{ reroll: { exact: ['2', 1] } }, { replace: { from: '6', to: '1' } }, { unique: true }],
                })).toMatchObject({
                    quantity: 4,
                    sides: 6,
                    modifiers: expect.arrayContaining([
                        { reroll: { exact: [2, 1] } },
                        { replace: { from: 6, to: 1 } },
                        { unique: true },
                    ]),
                });
            });
        });
        describe('complex', function () {
            test('returns a RollParameter matching the notation', function () {
                expect((0, parse_arguments_1.parseArguments)({
                    quantity: 4,
                    sides: '6',
                    modifiers: [
                        { plus: 2 },
                        { minus: 1 },
                        { drop: { highest: '5', greaterThan: '2', lessThan: '6', lowest: '1', exact: [2, '3'] } },
                        { reroll: [{ exact: ['2', 1] }] },
                        { cap: { greaterThan: '2', lessThan: 1 } },
                        { replace: [{ from: '6', to: '1' }] },
                        { unique: { notUnique: ['1', 2] } },
                        { explode: true },
                    ],
                })).toMatchObject({
                    quantity: 4,
                    sides: 6,
                    modifiers: expect.arrayContaining([
                        { drop: { highest: 5, greaterThan: 2, lessThan: 6, lowest: 1, exact: [2, 3] } },
                        { reroll: [{ exact: [2, 1] }] },
                        { cap: { greaterThan: 2, lessThan: 1 } },
                        { replace: [{ from: 6, to: 1 }] },
                        { unique: { notUnique: [1, 2] } },
                        { explode: true },
                        { plus: 2 },
                        { minus: 1 },
                    ]),
                });
            });
        });
    });
    describe('given DiceNotation', function () {
        var baseTestString = '4d6';
        var baseRollParameters = { sides: 6, quantity: 4 };
        describe('given a basic notation', function () {
            test('returns a RollParameter matching the notation', function () {
                expect((0, parse_arguments_1.parseArguments)(baseTestString)).toMatchObject(baseRollParameters);
            });
        });
        describe('given a notation that contains a drop highest modifier', function () {
            describe('with a simple notation', function () {
                var testString = "".concat(baseTestString, "H");
                test('returns a RollParameter matching the notation', function () {
                    expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([{ drop: { highest: 1 } }]) }));
                });
            });
            describe('with a complex notation', function () {
                var testString = "".concat(baseTestString, "H2");
                test('returns a RollParameter matching the notation', function () {
                    expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([{ drop: { highest: 2 } }]) }));
                });
            });
        });
        describe('given a notation that contains a drop lowest modifier', function () {
            describe('with a simple notation', function () {
                var testString = "".concat(baseTestString, "L");
                test('returns a RollParameter matching the notation', function () {
                    expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([{ drop: { lowest: 1 } }]) }));
                });
            });
            describe('with a complex notation', function () {
                var testString = "".concat(baseTestString, "L2");
                test('returns a RollParameter matching the notation', function () {
                    expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([{ drop: { lowest: 2 } }]) }));
                });
            });
        });
        describe('given a notation that contains a drop less than, greater than, and exact', function () {
            describe('simple', function () {
                var testString = "".concat(baseTestString, "D{<2,>5,2,4}");
                test('returns a RollParameter matching the notation', function () {
                    expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([{ drop: { greaterThan: 5, lessThan: 2, exact: [2, 4] } }]) }));
                });
            });
            describe('complex', function () {
                var testString = "400d20D{<2,>5,2,4}";
                test('returns a RollParameter matching the notation', function () {
                    expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject({
                        quantity: 400,
                        sides: 20,
                        modifiers: expect.arrayContaining([{ drop: { greaterThan: 5, lessThan: 2, exact: [2, 4] } }]),
                    });
                });
            });
        });
        describe('given a notation that contains a cap before and lessThan', function () {
            var testString = "".concat(baseTestString, "C<2>5");
            test('returns a RollParameter matching the notation', function () {
                expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([{ cap: { lessThan: 2, greaterThan: 5 } }]) }));
            });
        });
        describe('given a notation that contains a minus modifier', function () {
            var testString = "".concat(baseTestString, "-2");
            test('returns a RollParameter matching the notation', function () {
                expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([{ minus: 2 }]) }));
            });
        });
        describe('given a notation that contains a plus modifier', function () {
            var testString = "".concat(baseTestString, "+2");
            test('returns a RollParameter matching the notation', function () {
                expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([{ plus: 2 }]) }));
            });
        });
        describe('given a notation that contains a reroll modifier', function () {
            describe('with a simple value', function () {
                var testString = "".concat(baseTestString, "R{>6}");
                test('returns a RollParameter matching the notation', function () {
                    expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([{ reroll: { greaterThan: 6 } }]) }));
                });
            });
            describe('with a complex value', function () {
                var testString = "".concat(baseTestString, "R{5,2,<6}3");
                test('returns a RollParameter matching the notation', function () {
                    expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([{ reroll: { exact: [5, 2], lessThan: 6, maxReroll: 3 } }]) }));
                });
            });
        });
        describe('given a notation that contains a unique notation', function () {
            describe('with a unique notation', function () {
                var testString = "".concat(baseTestString, "U{5,6}");
                test('returns a RollParameter matching the notation', function () {
                    expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([{ unique: { notUnique: [5, 6] } }]) }));
                });
            });
            describe('with a simple unique notation', function () {
                var testString = "".concat(baseTestString, "U");
                test('returns a RollParameter matching the notation', function () {
                    expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([{ unique: true }]) }));
                });
            });
        });
        describe('given a notation that contains an explode modifier', function () {
            var testString = "".concat(baseTestString, "!");
            test('returns a RollParameter matching the notation', function () {
                expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([{ explode: true }]) }));
            });
        });
        describe('given a notation that contains a replace modifier', function () {
            describe('with multiple replacements', function () {
                var testString = "".concat(baseTestString, "V{1=2,>2=6}");
                test('returns a RollParameter matching the notation', function () {
                    expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([
                            {
                                replace: [
                                    { from: 1, to: 2 },
                                    { from: { greaterThan: 2 }, to: 6 },
                                ],
                            },
                        ]) }));
                });
            });
            describe('with a single replaceent', function () {
                var testString = "".concat(baseTestString, "V{<2=6}");
                test('returns a RollParameter matching the notation', function () {
                    expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject(__assign(__assign({}, baseRollParameters), { modifiers: expect.arrayContaining([{ replace: { from: { lessThan: 2 }, to: 6 } }]) }));
                });
            });
        });
        describe('With a complicated dice notation', function () {
            var testString = "10d20 H2 L V{1=2,>2=6} D{<2,>5,2,4} C<2>18 R{5,2,<6}3 U{5} ! +2 -5 +3";
            test('returns a RollParameter matching the notation', function () {
                expect((0, parse_arguments_1.parseArguments)(testString)).toMatchObject({
                    quantity: 10,
                    sides: 20,
                    modifiers: expect.arrayContaining([
                        { plus: 2 },
                        { plus: 3 },
                        { minus: 5 },
                        {
                            drop: {
                                highest: 2,
                            },
                        },
                        {
                            drop: {
                                lowest: 1,
                            },
                        },
                        {
                            drop: {
                                exact: [2, 4],
                                greaterThan: 5,
                                lessThan: 2,
                            },
                        },
                        { cap: { greaterThan: 18, lessThan: 2 } },
                        { reroll: { exact: [5, 2], lessThan: 6, maxReroll: 3 } },
                        { explode: true },
                        { unique: { notUnique: [5] } },
                        {
                            replace: [
                                { from: 1, to: 2 },
                                { from: { greaterThan: 2 }, to: 6 },
                            ],
                        },
                    ]),
                });
            });
        });
    });
});
//# sourceMappingURL=parse-arguments.test.js.map