"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var generate_rolls_1 = require("./generate-rolls");
var mockRandomizer = function () { return 200; };
describe('generateRolls', function () {
    var rollTotals = [1, 2, 3, 4];
    var baseParameters = { sides: 6, rolls: rollTotals.length };
    describe('when given roll totals with no modifiers', function () {
        test('it returns the sum total of the rolls and the roll totals', function () {
            expect((0, generate_rolls_1.generateRolls)(rollTotals, baseParameters, mockRandomizer)).toEqual([10, [1, 2, 3, 4]]);
        });
    });
    describe('when given roll totals with a "unique" modifier', function () {
        var duplicateRollTotals = [1, 1, 2, 3];
        var uniqueParameters = { sides: 4, rolls: duplicateRollTotals.length, unique: true };
        test('it re-rolls non-unique modifiers', function () {
            expect((0, generate_rolls_1.generateRolls)(duplicateRollTotals, uniqueParameters, mockRandomizer)).toEqual([206, [1, 200, 2, 3]]);
        });
        describe('when given a "notUnique" array', function () {
            var notUniqueParameters = __assign(__assign({}, uniqueParameters), { unique: { notUnique: [1] } });
            test('it disregards any numbers in that array and makes the rest unique', function () {
                expect((0, generate_rolls_1.generateRolls)(duplicateRollTotals, notUniqueParameters, mockRandomizer)).toEqual([7, [1, 1, 2, 3]]);
            });
        });
        describe('and the # of rolls is greater than the sides of the die', function () {
            var overflowRollTotals = [1, 1, 1, 2, 3, 4, 3, 3];
            var overflowParameters = __assign(__assign({}, uniqueParameters), { rolls: overflowRollTotals.length });
            test('it throws an error', function () {
                expect(function () { return (0, generate_rolls_1.generateRolls)(overflowRollTotals, overflowParameters, mockRandomizer); }).toThrow('You cannot have unique rolls when there are more rolls than sides of die.');
            });
        });
    });
    describe('when given roll totals with a "drop" modifier', function () {
        var longerRollTotals = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        var dropParameters = {
            sides: 10,
            rolls: longerRollTotals.length,
            drop: {
                highest: 1,
                lowest: 2,
                greaterThan: 8,
                lessThan: 2,
                exact: [5],
            },
        };
        test('it returns the total without the provided values', function () {
            expect((0, generate_rolls_1.generateRolls)(longerRollTotals, dropParameters, mockRandomizer)).toEqual([17, [4, 6, 7]]);
        });
    });
    describe('when given roll totals with a "replace" modifier', function () {
        describe('that is a single replace modifiers', function () {
            var dropParameters = __assign(__assign({}, baseParameters), { replace: { from: 1, to: 2 } });
            test('it returns the total with all values replaced according to the provided rules', function () {
                expect((0, generate_rolls_1.generateRolls)(rollTotals, dropParameters, mockRandomizer)).toEqual([11, [2, 2, 3, 4]]);
            });
        });
        describe('that is an array of replace modifiers', function () {
            var dropParameters = __assign(__assign({}, baseParameters), { replace: [
                    { from: 1, to: 2 },
                    { from: { above: 3 }, to: 6 },
                ] });
            test('it returns the total with all values replaced according to the provided rules', function () {
                expect((0, generate_rolls_1.generateRolls)(rollTotals, dropParameters, mockRandomizer)).toEqual([13, [2, 2, 3, 6]]);
            });
        });
    });
    describe('when given roll totals with an "explode" modifier', function () {
        var explodeRollTotals = [1, 2, 3, 6];
        var explodeParameters = __assign(__assign({}, baseParameters), { explode: true });
        test('it returns the total with all values matching the queries rerolled', function () {
            expect((0, generate_rolls_1.generateRolls)(explodeRollTotals, explodeParameters, mockRandomizer)).toEqual([212, [1, 2, 3, 6, 200]]);
        });
    });
    describe('when given roll totals with a "reroll" modifier', function () {
        describe('when given an impossible roll', function () {
            var rerollParameters = __assign(__assign({}, baseParameters), { reroll: { above: 3 } });
            test('it stops at 99 rerolls and returns the total with all values matching the queries rerolled', function () {
                expect((0, generate_rolls_1.generateRolls)(rollTotals, rerollParameters, mockRandomizer)).toEqual([206, [1, 2, 3, 200]]);
            });
        });
        describe('that is a single reroll modifier', function () {
            var rerollParameters = __assign(__assign({}, baseParameters), { reroll: { above: 3, on: 2, maxReroll: 2 } });
            test('it returns the total with all values matching the queries rerolled', function () {
                expect((0, generate_rolls_1.generateRolls)(rollTotals, rerollParameters, mockRandomizer)).toEqual([404, [1, 200, 3, 200]]);
            });
        });
        describe('that is an array of reroll modifiers', function () {
            var rerollParameters = __assign(__assign({}, baseParameters), { reroll: [{ below: 2, maxReroll: 2 }, { on: [3] }] });
            test('it returns the total with all values matching the queries rerolled', function () {
                expect((0, generate_rolls_1.generateRolls)(rollTotals, rerollParameters, mockRandomizer)).toEqual([406, [200, 2, 200, 4]]);
            });
        });
    });
    describe('when given roll totals with a "cap" modifier', function () {
        var dropParameters = __assign(__assign({}, baseParameters), { cap: { above: 3, below: 2 } });
        test('it returns the total with all values above above and below below replaced with their respective comparitor and the roll totals', function () {
            expect((0, generate_rolls_1.generateRolls)(rollTotals, dropParameters, mockRandomizer)).toEqual([10, [2, 2, 3, 3]]);
        });
    });
    describe('when given roll totals with a "plus" modifier', function () {
        var dropParameters = __assign(__assign({}, baseParameters), { plus: 2 });
        test('it returns the total plus the "plus" modifier, and the roll totals', function () {
            expect((0, generate_rolls_1.generateRolls)(rollTotals, dropParameters, mockRandomizer)).toEqual([12, [1, 2, 3, 4]]);
        });
    });
    describe('when given roll totals with a "minus" modifier', function () {
        var dropParameters = __assign(__assign({}, baseParameters), { minus: 2 });
        test('it returns the total minust the "minus" modifier, and the roll totals', function () {
            expect((0, generate_rolls_1.generateRolls)(rollTotals, dropParameters, mockRandomizer)).toEqual([8, [1, 2, 3, 4]]);
        });
    });
});
//# sourceMappingURL=generate-rolls.test.js.map