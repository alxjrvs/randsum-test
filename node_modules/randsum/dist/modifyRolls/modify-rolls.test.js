"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var modify_rolls_1 = require("./modify-rolls");
var mockRandomizer = function () { return 200; };
describe('modifyRolls', function () {
    var rolls = [1, 2, 3, 4];
    var baseParameters = { sides: 6, quantity: rolls.length };
    describe('when given roll total with no modifiers', function () {
        test('it returns the sum total of the quantity and the roll total', function () {
            expect((0, modify_rolls_1.modifyRolls)(rolls, baseParameters, mockRandomizer)).toMatchObject({ total: 10, rolls: [1, 2, 3, 4] });
        });
    });
    describe('when given roll total with a "unique" modifier', function () {
        var duplicateRollTotals = [1, 1, 2, 3];
        var uniqueParameters = {
            sides: 4,
            quantity: duplicateRollTotals.length,
            modifiers: [{ unique: true }],
        };
        test('it re-quantity non-unique modifiers', function () {
            expect((0, modify_rolls_1.modifyRolls)(duplicateRollTotals, uniqueParameters, mockRandomizer)).toMatchObject({
                total: 206,
                rolls: [1, 200, 2, 3],
            });
        });
        describe('when given a "notUnique" array', function () {
            var notUniqueParameters = __assign(__assign({}, uniqueParameters), { modifiers: [{ unique: { notUnique: [1] } }] });
            test('it disregards any numbers in that array and makes the rest unique', function () {
                expect((0, modify_rolls_1.modifyRolls)(duplicateRollTotals, notUniqueParameters, mockRandomizer)).toMatchObject({
                    total: 7,
                    rolls: [1, 1, 2, 3],
                });
            });
        });
        describe('and the # of quantity is greater than the sides of the die', function () {
            var overflowRollTotals = [1, 1, 1, 2, 3, 4, 3, 3];
            var overflowParameters = __assign(__assign({}, uniqueParameters), { quantity: overflowRollTotals.length });
            test('it throws an error', function () {
                expect(function () { return (0, modify_rolls_1.modifyRolls)(overflowRollTotals, overflowParameters, mockRandomizer); }).toThrow('You cannot have unique rolls when there are more rolls than sides of die.');
            });
        });
    });
    describe('when given roll total with a "drop" modifier', function () {
        var longerRollTotals = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        var dropParameters = {
            sides: 10,
            quantity: longerRollTotals.length,
            modifiers: [
                {
                    drop: {
                        highest: 1,
                        lowest: 2,
                        greaterThan: 8,
                        lessThan: 2,
                        exact: [5],
                    },
                },
            ],
        };
        test('it returns the total without the provided values', function () {
            expect((0, modify_rolls_1.modifyRolls)(longerRollTotals, dropParameters, mockRandomizer)).toMatchObject({
                total: 17,
                rolls: [4, 6, 7],
            });
        });
    });
    describe('when given roll total with a "replace" modifier', function () {
        describe('that is a single replace modifiers', function () {
            var dropParameters = __assign(__assign({}, baseParameters), { modifiers: [{ replace: { from: 1, to: 2 } }] });
            test('it returns the total with all values replaced according to the provided rules', function () {
                expect((0, modify_rolls_1.modifyRolls)(rolls, dropParameters, mockRandomizer)).toMatchObject({ total: 11, rolls: [2, 2, 3, 4] });
            });
        });
        describe('that is an array of replace modifiers', function () {
            var dropParameters = __assign(__assign({}, baseParameters), { modifiers: [
                    {
                        replace: [
                            { from: 1, to: 2 },
                            { from: { greaterThan: 3 }, to: 6 },
                        ],
                    },
                ] });
            test('it returns the total with all values replaced according to the provided rules', function () {
                expect((0, modify_rolls_1.modifyRolls)(rolls, dropParameters, mockRandomizer)).toMatchObject({ total: 13, rolls: [2, 2, 3, 6] });
            });
        });
    });
    describe('when given roll total with an "explode" modifier', function () {
        var explodeRollTotals = [1, 2, 3, 6];
        var explodeParameters = __assign(__assign({}, baseParameters), { modifiers: [{ explode: true }] });
        test('it returns the total with all values matching the queries rerolled', function () {
            expect((0, modify_rolls_1.modifyRolls)(explodeRollTotals, explodeParameters, mockRandomizer)).toMatchObject({
                total: 212,
                rolls: [1, 2, 3, 6, 200],
            });
        });
    });
    describe('when given roll total with a "reroll" modifier', function () {
        describe('when given an impossible roll', function () {
            var rerollParameters = __assign(__assign({}, baseParameters), { modifiers: [{ reroll: { greaterThan: 3 } }] });
            test('it stops at 99 rerolls and returns the total with all values matching the queries rerolled', function () {
                expect((0, modify_rolls_1.modifyRolls)(rolls, rerollParameters, mockRandomizer)).toMatchObject({
                    total: 206,
                    rolls: [1, 2, 3, 200],
                });
            });
        });
        describe('that is a single reroll modifier', function () {
            var rerollParameters = __assign(__assign({}, baseParameters), { modifiers: [{ reroll: { greaterThan: 3, exact: 2, maxReroll: 2 } }] });
            test('it returns the total with all values matching the queries rerolled', function () {
                expect((0, modify_rolls_1.modifyRolls)(rolls, rerollParameters, mockRandomizer)).toMatchObject({
                    total: 404,
                    rolls: [1, 200, 3, 200],
                });
            });
        });
        describe('that is an array of reroll modifiers', function () {
            var rerollParameters = __assign(__assign({}, baseParameters), { modifiers: [{ reroll: [{ lessThan: 2, maxReroll: 2 }, { exact: [3] }] }] });
            test('it returns the total with all values matching the queries rerolled', function () {
                expect((0, modify_rolls_1.modifyRolls)(rolls, rerollParameters, mockRandomizer)).toMatchObject({
                    total: 406,
                    rolls: [200, 2, 200, 4],
                });
            });
        });
    });
    describe('when given roll total with a "cap" modifier', function () {
        var dropParameters = __assign(__assign({}, baseParameters), { modifiers: [{ cap: { greaterThan: 3, lessThan: 2 } }] });
        test('it returns the total with all values greaterThan greaterThan and lessThan lessThan replaced with their respective comparitor and the roll total', function () {
            expect((0, modify_rolls_1.modifyRolls)(rolls, dropParameters, mockRandomizer)).toMatchObject({ total: 10, rolls: [2, 2, 3, 3] });
        });
    });
    describe('when given roll total with a "plus" modifier', function () {
        var dropParameters = __assign(__assign({}, baseParameters), { modifiers: [{ plus: 2 }] });
        test('it returns the total plus the "plus" modifier, and the roll total', function () {
            expect((0, modify_rolls_1.modifyRolls)(rolls, dropParameters, mockRandomizer)).toMatchObject({ total: 12, rolls: [1, 2, 3, 4] });
        });
    });
    describe('when given roll total with a "minus" modifier', function () {
        var dropParameters = __assign(__assign({}, baseParameters), { modifiers: [{ minus: 2 }] });
        test('it returns the total minust the "minus" modifier, and the roll total', function () {
            expect((0, modify_rolls_1.modifyRolls)(rolls, dropParameters, mockRandomizer)).toMatchObject({ total: 8, rolls: [1, 2, 3, 4] });
        });
    });
});
//# sourceMappingURL=modify-rolls.test.js.map